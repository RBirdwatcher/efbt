/*
 * generated by Xtext 2.22.0
 */
package org.eclipse.efbt.chirp.serializer;

import com.google.inject.Inject;
import java.util.Set;
import org.eclipse.efbt.chirp.chirp_program.Chirp_programPackage;
import org.eclipse.efbt.chirp.chirp_program.Program;
import org.eclipse.efbt.chirp.services.ChirpGrammarAccess;
import org.eclipse.efbt.common.model.module_management.ModuleDependencies;
import org.eclipse.efbt.common.model.module_management.ModuleDependency;
import org.eclipse.efbt.common.model.module_management.ModuleLongName;
import org.eclipse.efbt.common.model.module_management.Module_managementPackage;
import org.eclipse.efbt.data_structures.smcubes.model.core.CorePackage;
import org.eclipse.efbt.data_structures.smcubes.model.core.DOMAIN;
import org.eclipse.efbt.data_structures.smcubes.model.core.FACET_COLLECTION;
import org.eclipse.efbt.data_structures.smcubes.model.core.MAINTENANCE_AGENCY;
import org.eclipse.efbt.data_structures.smcubes.model.core.MEMBER;
import org.eclipse.efbt.data_structures.smcubes.model.core.SUBDOMAIN;
import org.eclipse.efbt.data_structures.smcubes.model.core.VARIABLE;
import org.eclipse.efbt.data_structures.smcubes.model.core.VARIABLE_SET;
import org.eclipse.efbt.data_structures.smcubes.model.data_definition.COMBINATION;
import org.eclipse.efbt.data_structures.smcubes.model.data_definition.COMBINATION_ITEM;
import org.eclipse.efbt.data_structures.smcubes.model.data_definition.CUBE;
import org.eclipse.efbt.data_structures.smcubes.model.data_definition.CUBE_STRUCTURE;
import org.eclipse.efbt.data_structures.smcubes.model.data_definition.CUBE_STRUCTURE_ITEM;
import org.eclipse.efbt.data_structures.smcubes.model.data_definition.CUBE_TO_COMBINATION;
import org.eclipse.efbt.data_structures.smcubes.model.data_definition.Data_definitionPackage;
import org.eclipse.efbt.data_structures.smcubes.model.data_definition.FRAMEWORK;
import org.eclipse.efbt.data_structures.smcubes.model.efbt_data_definition.CombinationModule;
import org.eclipse.efbt.data_structures.smcubes.model.efbt_data_definition.CubeModule;
import org.eclipse.efbt.data_structures.smcubes.model.efbt_data_definition.DomainModule;
import org.eclipse.efbt.data_structures.smcubes.model.efbt_data_definition.Efbt_data_definitionPackage;
import org.eclipse.efbt.data_structures.smcubes.model.efbt_data_definition.MemberModule;
import org.eclipse.efbt.data_structures.smcubes.model.efbt_data_definition.VariableModule;
import org.eclipse.efbt.data_structures.smcubes.model.efbt_mapping.Efbt_mappingPackage;
import org.eclipse.efbt.data_structures.smcubes.model.efbt_mapping.MappingDefinitionModule;
import org.eclipse.efbt.data_structures.smcubes.model.efbt_vtl_transformation.Efbt_vtl_transformationPackage;
import org.eclipse.efbt.data_structures.smcubes.model.efbt_vtl_transformation.TransformationSchemeModule;
import org.eclipse.efbt.data_structures.smcubes.model.mapping.MAPPING_DEFINITION;
import org.eclipse.efbt.data_structures.smcubes.model.mapping.MEMBER_MAPPING;
import org.eclipse.efbt.data_structures.smcubes.model.mapping.MEMBER_MAPPING_ITEM;
import org.eclipse.efbt.data_structures.smcubes.model.mapping.MappingPackage;
import org.eclipse.efbt.data_structures.smcubes.model.mapping.VARIABLE_MAPPING;
import org.eclipse.efbt.data_structures.smcubes.model.mapping.VARIABLE_MAPPING_ITEM;
import org.eclipse.efbt.data_structures.smcubes.model.smcubes_model.SmcubesModel;
import org.eclipse.efbt.data_structures.smcubes.model.smcubes_model.Smcubes_modelPackage;
import org.eclipse.efbt.data_structures.smcubes.model.vtl_transformation.TRANSFORMATION_SCHEME;
import org.eclipse.efbt.data_structures.smcubes.model.vtl_transformation.Vtl_transformationPackage;
import org.eclipse.efbt.functional_design.core.model.functionality_module.DataProcessingFunctionalityModule;
import org.eclipse.efbt.functional_design.core.model.functionality_module.FunctionalityModuleModule;
import org.eclipse.efbt.functional_design.core.model.functionality_module.FunctionalityModuleSet;
import org.eclipse.efbt.functional_design.core.model.functionality_module.Functionality_modulePackage;
import org.eclipse.efbt.functional_design.core.model.functionality_module.LeafFunctionalityModule;
import org.eclipse.efbt.functional_design.core.model.functionality_module.ParallelFunctionalityModule;
import org.eclipse.efbt.functional_design.core.model.functionality_module.ReadDataSourceFunctionalityModule;
import org.eclipse.efbt.functional_design.core.model.functionality_module.ScenarioSetFunctionalityModule;
import org.eclipse.efbt.functional_design.core.model.functionality_module.SerialFunctionalityModule;
import org.eclipse.efbt.functional_design.core.model.functionality_module.ValidationFunctionalityModule;
import org.eclipse.efbt.functional_design.core.model.scenarios.Scenario;
import org.eclipse.efbt.functional_design.core.model.scenarios.ScenarioSet;
import org.eclipse.efbt.functional_design.core.model.scenarios.ScenariosPackage;
import org.eclipse.efbt.requirements.core.model.requirements_text.AllowedTypes;
import org.eclipse.efbt.requirements.core.model.requirements_text.RequirementType;
import org.eclipse.efbt.requirements.core.model.requirements_text.RequirementsModule;
import org.eclipse.efbt.requirements.core.model.requirements_text.RequirementsSectionImage;
import org.eclipse.efbt.requirements.core.model.requirements_text.RequirementsSectionLinkWithText;
import org.eclipse.efbt.requirements.core.model.requirements_text.RequirementsSectionText;
import org.eclipse.efbt.requirements.core.model.requirements_text.Requirements_textPackage;
import org.eclipse.efbt.requirements.core.model.requirements_text.TitledRequirementsSection;
import org.eclipse.efbt.testing.common.model.test.E2ETest;
import org.eclipse.efbt.testing.common.model.test.Result;
import org.eclipse.efbt.testing.common.model.test.TestModule;
import org.eclipse.efbt.testing.common.model.test.TestPackage;
import org.eclipse.efbt.testing.common.model.test_definition.ClauseText;
import org.eclipse.efbt.testing.common.model.test_definition.E2ETestDefinition;
import org.eclipse.efbt.testing.common.model.test_definition.Given;
import org.eclipse.efbt.testing.common.model.test_definition.Param;
import org.eclipse.efbt.testing.common.model.test_definition.TestContraints;
import org.eclipse.efbt.testing.common.model.test_definition.TestDefinition;
import org.eclipse.efbt.testing.common.model.test_definition.TestDefinitionModule;
import org.eclipse.efbt.testing.common.model.test_definition.TestTemplate;
import org.eclipse.efbt.testing.common.model.test_definition.TestTemplateModule;
import org.eclipse.efbt.testing.common.model.test_definition.Test_definitionPackage;
import org.eclipse.efbt.testing.common.model.test_definition.Then;
import org.eclipse.efbt.testing.common.model.test_definition.UnitTestDefinition;
import org.eclipse.efbt.testing.common.model.test_definition.When;
import org.eclipse.efbt.testing.common.model.test_input_data.TestInputData;
import org.eclipse.efbt.testing.common.model.test_input_data.Test_input_dataPackage;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.emf.ecore.EcorePackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;

@SuppressWarnings("all")
public class ChirpSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private ChirpGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == Chirp_programPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case Chirp_programPackage.PROGRAM:
				sequence_rogram(context, (Program) semanticObject); 
				return; 
			}
		else if (epackage == CorePackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case CorePackage.DOMAIN:
				sequence_DOMAIN(context, (DOMAIN) semanticObject); 
				return; 
			case CorePackage.FACET_COLLECTION:
				sequence_FACET_COLLECTION(context, (FACET_COLLECTION) semanticObject); 
				return; 
			case CorePackage.MAINTENANCE_AGENCY:
				sequence_MAINTENANCE_AGENCY(context, (MAINTENANCE_AGENCY) semanticObject); 
				return; 
			case CorePackage.MEMBER:
				sequence_MEMBER(context, (MEMBER) semanticObject); 
				return; 
			case CorePackage.SUBDOMAIN:
				sequence_SUBDOMAIN(context, (SUBDOMAIN) semanticObject); 
				return; 
			case CorePackage.VARIABLE:
				sequence_VARIABLE(context, (VARIABLE) semanticObject); 
				return; 
			case CorePackage.VARIABLE_SET:
				sequence_VARIABLE_SET(context, (VARIABLE_SET) semanticObject); 
				return; 
			}
		else if (epackage == Data_definitionPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case Data_definitionPackage.COMBINATION:
				sequence_COMBINATION(context, (COMBINATION) semanticObject); 
				return; 
			case Data_definitionPackage.COMBINATION_ITEM:
				sequence_COMBINATION_ITEM(context, (COMBINATION_ITEM) semanticObject); 
				return; 
			case Data_definitionPackage.CUBE:
				sequence_CUBE(context, (CUBE) semanticObject); 
				return; 
			case Data_definitionPackage.CUBE_STRUCTURE:
				sequence_CUBE_STRUCTURE(context, (CUBE_STRUCTURE) semanticObject); 
				return; 
			case Data_definitionPackage.CUBE_STRUCTURE_ITEM:
				sequence_CUBE_STRUCTURE_ITEM(context, (CUBE_STRUCTURE_ITEM) semanticObject); 
				return; 
			case Data_definitionPackage.CUBE_TO_COMBINATION:
				sequence_CUBE_TO_COMBINATION(context, (CUBE_TO_COMBINATION) semanticObject); 
				return; 
			case Data_definitionPackage.FRAMEWORK:
				sequence_FRAMEWORK(context, (FRAMEWORK) semanticObject); 
				return; 
			}
		else if (epackage == EcorePackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case EcorePackage.EOBJECT:
				sequence_EObject(context, (EObject) semanticObject); 
				return; 
			}
		else if (epackage == Efbt_data_definitionPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case Efbt_data_definitionPackage.COMBINATION_MODULE:
				sequence_CombinationModule(context, (CombinationModule) semanticObject); 
				return; 
			case Efbt_data_definitionPackage.CUBE_MODULE:
				sequence_CubeModule(context, (CubeModule) semanticObject); 
				return; 
			case Efbt_data_definitionPackage.DOMAIN_MODULE:
				sequence_DomainModule(context, (DomainModule) semanticObject); 
				return; 
			case Efbt_data_definitionPackage.MEMBER_MODULE:
				sequence_MemberModule(context, (MemberModule) semanticObject); 
				return; 
			case Efbt_data_definitionPackage.VARIABLE_MODULE:
				sequence_VariableModule(context, (VariableModule) semanticObject); 
				return; 
			}
		else if (epackage == Efbt_mappingPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case Efbt_mappingPackage.MAPPING_DEFINITION_MODULE:
				sequence_MappingDefinitionModule(context, (MappingDefinitionModule) semanticObject); 
				return; 
			}
		else if (epackage == Efbt_vtl_transformationPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case Efbt_vtl_transformationPackage.TRANSFORMATION_SCHEME_MODULE:
				sequence_TransformationSchemeModule(context, (TransformationSchemeModule) semanticObject); 
				return; 
			}
		else if (epackage == Functionality_modulePackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case Functionality_modulePackage.DATA_PROCESSING_FUNCTIONALITY_MODULE:
				sequence_DataProcessingFunctionalityModule(context, (DataProcessingFunctionalityModule) semanticObject); 
				return; 
			case Functionality_modulePackage.FUNCTIONALITY_MODULE_MODULE:
				sequence_FunctionalityModuleModule(context, (FunctionalityModuleModule) semanticObject); 
				return; 
			case Functionality_modulePackage.FUNCTIONALITY_MODULE_SET:
				sequence_FunctionalityModuleSet_Impl(context, (FunctionalityModuleSet) semanticObject); 
				return; 
			case Functionality_modulePackage.LEAF_FUNCTIONALITY_MODULE:
				sequence_LeafFunctionalityModule_Impl(context, (LeafFunctionalityModule) semanticObject); 
				return; 
			case Functionality_modulePackage.PARALLEL_FUNCTIONALITY_MODULE:
				sequence_ParallelFunctionalityModule(context, (ParallelFunctionalityModule) semanticObject); 
				return; 
			case Functionality_modulePackage.READ_DATA_SOURCE_FUNCTIONALITY_MODULE:
				sequence_ReadDataSourceFunctionalityModule(context, (ReadDataSourceFunctionalityModule) semanticObject); 
				return; 
			case Functionality_modulePackage.SCENARIO_SET_FUNCTIONALITY_MODULE:
				sequence_ScenarioSetFunctionalityModule(context, (ScenarioSetFunctionalityModule) semanticObject); 
				return; 
			case Functionality_modulePackage.SERIAL_FUNCTIONALITY_MODULE:
				sequence_SerialFunctionalityModule(context, (SerialFunctionalityModule) semanticObject); 
				return; 
			case Functionality_modulePackage.VALIDATION_FUNCTIONALITY_MODULE:
				sequence_ValidationFunctionalityModule(context, (ValidationFunctionalityModule) semanticObject); 
				return; 
			}
		else if (epackage == MappingPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case MappingPackage.MAPPING_DEFINITION:
				sequence_MAPPING_DEFINITION(context, (MAPPING_DEFINITION) semanticObject); 
				return; 
			case MappingPackage.MEMBER_MAPPING:
				sequence_MEMBER_MAPPING(context, (MEMBER_MAPPING) semanticObject); 
				return; 
			case MappingPackage.MEMBER_MAPPING_ITEM:
				sequence_MEMBER_MAPPING_ITEM(context, (MEMBER_MAPPING_ITEM) semanticObject); 
				return; 
			case MappingPackage.VARIABLE_MAPPING:
				sequence_VARIABLE_MAPPING(context, (VARIABLE_MAPPING) semanticObject); 
				return; 
			case MappingPackage.VARIABLE_MAPPING_ITEM:
				sequence_VARIABLE_MAPPING_ITEM(context, (VARIABLE_MAPPING_ITEM) semanticObject); 
				return; 
			}
		else if (epackage == Module_managementPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case Module_managementPackage.MODULE_DEPENDENCIES:
				sequence_ModuleDependencies(context, (ModuleDependencies) semanticObject); 
				return; 
			case Module_managementPackage.MODULE_DEPENDENCY:
				sequence_ModuleDependency(context, (ModuleDependency) semanticObject); 
				return; 
			case Module_managementPackage.MODULE_LONG_NAME:
				sequence_ModuleLongName(context, (ModuleLongName) semanticObject); 
				return; 
			}
		else if (epackage == Requirements_textPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case Requirements_textPackage.ALLOWED_TYPES:
				sequence_AllowedTypes(context, (AllowedTypes) semanticObject); 
				return; 
			case Requirements_textPackage.REQUIREMENT_TYPE:
				sequence_RequirementType(context, (RequirementType) semanticObject); 
				return; 
			case Requirements_textPackage.REQUIREMENTS_MODULE:
				sequence_RequirementsModule(context, (RequirementsModule) semanticObject); 
				return; 
			case Requirements_textPackage.REQUIREMENTS_SECTION_IMAGE:
				sequence_RequirementsSectionImage(context, (RequirementsSectionImage) semanticObject); 
				return; 
			case Requirements_textPackage.REQUIREMENTS_SECTION_LINK_WITH_TEXT:
				sequence_RequirementsSectionLinkWithText(context, (RequirementsSectionLinkWithText) semanticObject); 
				return; 
			case Requirements_textPackage.REQUIREMENTS_SECTION_TEXT:
				sequence_RequirementsSectionText(context, (RequirementsSectionText) semanticObject); 
				return; 
			case Requirements_textPackage.TITLED_REQUIREMENTS_SECTION:
				sequence_TitledRequirementsSection(context, (TitledRequirementsSection) semanticObject); 
				return; 
			}
		else if (epackage == ScenariosPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case ScenariosPackage.SCENARIO:
				sequence_Scenario(context, (Scenario) semanticObject); 
				return; 
			case ScenariosPackage.SCENARIO_SET:
				sequence_ScenarioSet(context, (ScenarioSet) semanticObject); 
				return; 
			}
		else if (epackage == Smcubes_modelPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case Smcubes_modelPackage.SMCUBES_MODEL:
				sequence_SmcubesModel(context, (SmcubesModel) semanticObject); 
				return; 
			}
		else if (epackage == TestPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case TestPackage.E2E_TEST:
				sequence_E2ETest(context, (E2ETest) semanticObject); 
				return; 
			case TestPackage.RESULT:
				sequence_Result(context, (Result) semanticObject); 
				return; 
			case TestPackage.TEST_MODULE:
				sequence_TestModule(context, (TestModule) semanticObject); 
				return; 
			}
		else if (epackage == Test_definitionPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case Test_definitionPackage.CLAUSE_TEXT:
				sequence_ClauseText(context, (ClauseText) semanticObject); 
				return; 
			case Test_definitionPackage.E2E_TEST_DEFINITION:
				sequence_E2ETestDefinition(context, (E2ETestDefinition) semanticObject); 
				return; 
			case Test_definitionPackage.GIVEN:
				sequence_Given(context, (Given) semanticObject); 
				return; 
			case Test_definitionPackage.PARAM:
				sequence_Param(context, (Param) semanticObject); 
				return; 
			case Test_definitionPackage.TEST_CONTRAINTS:
				sequence_TestContraints(context, (TestContraints) semanticObject); 
				return; 
			case Test_definitionPackage.TEST_DEFINITION:
				sequence_TestDefinition_Impl(context, (TestDefinition) semanticObject); 
				return; 
			case Test_definitionPackage.TEST_DEFINITION_MODULE:
				sequence_TestDefinitionModule(context, (TestDefinitionModule) semanticObject); 
				return; 
			case Test_definitionPackage.TEST_TEMPLATE:
				sequence_TestTemplate(context, (TestTemplate) semanticObject); 
				return; 
			case Test_definitionPackage.TEST_TEMPLATE_MODULE:
				sequence_TestTemplateModule(context, (TestTemplateModule) semanticObject); 
				return; 
			case Test_definitionPackage.THEN:
				sequence_Then(context, (Then) semanticObject); 
				return; 
			case Test_definitionPackage.UNIT_TEST_DEFINITION:
				sequence_UnitTestDefinition(context, (UnitTestDefinition) semanticObject); 
				return; 
			case Test_definitionPackage.WHEN:
				sequence_When(context, (When) semanticObject); 
				return; 
			}
		else if (epackage == Test_input_dataPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case Test_input_dataPackage.TEST_INPUT_DATA:
				sequence_TestInputData(context, (TestInputData) semanticObject); 
				return; 
			}
		else if (epackage == Vtl_transformationPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case Vtl_transformationPackage.TRANSFORMATION_SCHEME:
				sequence_TRANSFORMATION_SCHEME(context, (TRANSFORMATION_SCHEME) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Contexts:
	 *     AllowedTypes returns AllowedTypes
	 *
	 * Constraint:
	 *     (allowedTypes+=RequirementType allowedTypes+=RequirementType*)?
	 */
	protected void sequence_AllowedTypes(ISerializationContext context, AllowedTypes semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     COMBINATION returns COMBINATION
	 *
	 * Constraint:
	 *     (
	 *         combination_id=EString 
	 *         code=EString? 
	 *         name=EString? 
	 *         valid_from=EDate? 
	 *         valid_to=EDate? 
	 *         version=EString? 
	 *         maintenance_agency_id=[MAINTENANCE_AGENCY|QualifiedName]? 
	 *         (combination_items+=COMBINATION_ITEM combination_items+=COMBINATION_ITEM*)?
	 *     )
	 */
	protected void sequence_COMBINATION(ISerializationContext context, COMBINATION semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     COMBINATION_ITEM returns COMBINATION_ITEM
	 *
	 * Constraint:
	 *     (
	 *         member_id=[MEMBER|QualifiedName]? 
	 *         subdomain_id=[SUBDOMAIN|QualifiedName]? 
	 *         variable_id=[VARIABLE|QualifiedName]? 
	 *         variable_set_id=[VARIABLE_SET|QualifiedName]?
	 *     )
	 */
	protected void sequence_COMBINATION_ITEM(ISerializationContext context, COMBINATION_ITEM semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     CUBE returns CUBE
	 *
	 * Constraint:
	 *     (
	 *         is_allowed?='is_allowed'? 
	 *         published?='published'? 
	 *         cube_id=EString 
	 *         code=EString? 
	 *         cube_type=EString? 
	 *         description=EString? 
	 *         name=EString? 
	 *         valid_from=EDate? 
	 *         valid_to=EDate? 
	 *         version=EString? 
	 *         cube_structure_id=[CUBE_STRUCTURE|QualifiedName]? 
	 *         framework_id=[FRAMEWORK|QualifiedName]? 
	 *         maintenance_agency_id=[MAINTENANCE_AGENCY|QualifiedName]?
	 *     )
	 */
	protected void sequence_CUBE(ISerializationContext context, CUBE semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     CUBE_STRUCTURE returns CUBE_STRUCTURE
	 *
	 * Constraint:
	 *     (
	 *         cube_structure_id=EString 
	 *         code=EString? 
	 *         description=EString? 
	 *         name=EString? 
	 *         valid_from=EDate? 
	 *         valid_to=EDate? 
	 *         version=EString? 
	 *         maintenance_agency_id=[MAINTENANCE_AGENCY|QualifiedName]?
	 *     )
	 */
	protected void sequence_CUBE_STRUCTURE(ISerializationContext context, CUBE_STRUCTURE semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     CUBE_STRUCTURE_ITEM returns CUBE_STRUCTURE_ITEM
	 *
	 * Constraint:
	 *     (
	 *         is_flow?='is_flow'? 
	 *         is_mandatory?='is_mandatory'? 
	 *         isIdentifier?='isIdentifier'? 
	 *         description=EString? 
	 *         dimension_type=TYP_DMNSN? 
	 *         order=EInt? 
	 *         role=TYP_RL? 
	 *         cube_variable_code=EString? 
	 *         attribute_associated_variable=[VARIABLE|QualifiedName]? 
	 *         cube_structure_id=[CUBE_STRUCTURE|QualifiedName]? 
	 *         member_id=[MEMBER|QualifiedName]? 
	 *         subdomain_id=[SUBDOMAIN|QualifiedName]? 
	 *         variable_id=[VARIABLE|QualifiedName]? 
	 *         variable_set_id=[VARIABLE_SET|QualifiedName]?
	 *     )
	 */
	protected void sequence_CUBE_STRUCTURE_ITEM(ISerializationContext context, CUBE_STRUCTURE_ITEM semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     CUBE_TO_COMBINATION returns CUBE_TO_COMBINATION
	 *
	 * Constraint:
	 *     (combination_id=[COMBINATION|QualifiedName]? cube_id=[CUBE|QualifiedName]?)
	 */
	protected void sequence_CUBE_TO_COMBINATION(ISerializationContext context, CUBE_TO_COMBINATION semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ClauseText returns ClauseText
	 *
	 * Constraint:
	 *     name=EString
	 */
	protected void sequence_ClauseText(ISerializationContext context, ClauseText semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, Test_definitionPackage.Literals.CLAUSE_TEXT__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, Test_definitionPackage.Literals.CLAUSE_TEXT__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getClauseTextAccess().getNameEStringParserRuleCall_2_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     CombinationModule returns CombinationModule
	 *
	 * Constraint:
	 *     (
	 *         name=EString 
	 *         theDescription=EString? 
	 *         license=EString? 
	 *         version=EString? 
	 *         dependencies=ModuleDependencies? 
	 *         longName=ModuleLongName? 
	 *         (combinations+=COMBINATION combinations+=COMBINATION*)? 
	 *         (combination_items+=COMBINATION_ITEM combination_items+=COMBINATION_ITEM*)? 
	 *         (cubeToCombinationLinks+=CUBE_TO_COMBINATION cubeToCombinationLinks+=CUBE_TO_COMBINATION*)?
	 *     )
	 */
	protected void sequence_CombinationModule(ISerializationContext context, CombinationModule semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     CubeModule returns CubeModule
	 *
	 * Constraint:
	 *     (
	 *         name=EString 
	 *         theDescription=EString? 
	 *         license=EString? 
	 *         version=EString? 
	 *         dependencies=ModuleDependencies? 
	 *         longName=ModuleLongName? 
	 *         (cubes+=CUBE cubes+=CUBE*)? 
	 *         (cubeStructures+=CUBE_STRUCTURE cubeStructures+=CUBE_STRUCTURE*)? 
	 *         (cubeStructureItems+=CUBE_STRUCTURE_ITEM cubeStructureItems+=CUBE_STRUCTURE_ITEM*)?
	 *     )
	 */
	protected void sequence_CubeModule(ISerializationContext context, CubeModule semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     DOMAIN returns DOMAIN
	 *
	 * Constraint:
	 *     (
	 *         is_enumerated?='is_enumerated'? 
	 *         is_reference?='is_reference'? 
	 *         name=EString 
	 *         code=EString? 
	 *         data_type=FACET_VALUE_TYPE? 
	 *         description=EString? 
	 *         domain_id=EString? 
	 *         facet_id=[FACET_COLLECTION|QualifiedName]? 
	 *         maintenance_agency_id=[MAINTENANCE_AGENCY|QualifiedName]?
	 *     )
	 */
	protected void sequence_DOMAIN(ISerializationContext context, DOMAIN semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     FunctionalityModule returns DataProcessingFunctionalityModule
	 *     DataProcessingFunctionalityModule returns DataProcessingFunctionalityModule
	 *
	 * Constraint:
	 *     (name=EString usedTransformationOrScheme=[FunctionalityModule|QualifiedName]? scenario=[Scenario|QualifiedName]? scenarioSet=ScenarioSet?)
	 */
	protected void sequence_DataProcessingFunctionalityModule(ISerializationContext context, DataProcessingFunctionalityModule semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     DomainModule returns DomainModule
	 *
	 * Constraint:
	 *     (
	 *         name=EString 
	 *         theDescription=EString? 
	 *         license=EString? 
	 *         version=EString? 
	 *         dependencies=ModuleDependencies? 
	 *         longName=ModuleLongName? 
	 *         (domains+=DOMAIN domains+=DOMAIN*)?
	 *     )
	 */
	protected void sequence_DomainModule(ISerializationContext context, DomainModule semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     TestDefinition returns E2ETestDefinition
	 *     E2ETestDefinition returns E2ETestDefinition
	 *
	 * Constraint:
	 *     (name=EString testContraints=[TestContraints|QualifiedName]? given=Given? when=When? then=Then?)
	 */
	protected void sequence_E2ETestDefinition(ISerializationContext context, E2ETestDefinition semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     E2ETest returns E2ETest
	 *
	 * Constraint:
	 *     (name=EString testDefinition=[E2ETestDefinition|QualifiedName]? inputData=TestInputData? expectedResults=Result?)
	 */
	protected void sequence_E2ETest(ISerializationContext context, E2ETest semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     EObject returns EObject
	 *
	 * Constraint:
	 *     {EObject}
	 */
	protected void sequence_EObject(ISerializationContext context, EObject semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     FACET_COLLECTION returns FACET_COLLECTION
	 *
	 * Constraint:
	 *     (facet_id=EString code=EString? facet_value_type=FACET_VALUE_TYPE? name=EString? maintenance_agency_id=[FACET_COLLECTION|QualifiedName]?)
	 */
	protected void sequence_FACET_COLLECTION(ISerializationContext context, FACET_COLLECTION semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     FRAMEWORK returns FRAMEWORK
	 *
	 * Constraint:
	 *     (framework_id=EString code=EString? description=EString? name=EString? maintenance_agency_id=[MAINTENANCE_AGENCY|QualifiedName]?)
	 */
	protected void sequence_FRAMEWORK(ISerializationContext context, FRAMEWORK semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     FunctionalityModuleModule returns FunctionalityModuleModule
	 *
	 * Constraint:
	 *     (
	 *         name=EString 
	 *         theDescription=EString? 
	 *         license=EString? 
	 *         version=EString? 
	 *         dependencies=ModuleDependencies? 
	 *         longName=ModuleLongName? 
	 *         (FunctionalityModules+=FunctionalityModule FunctionalityModules+=FunctionalityModule*)?
	 *     )
	 */
	protected void sequence_FunctionalityModuleModule(ISerializationContext context, FunctionalityModuleModule semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     FunctionalityModule returns FunctionalityModuleSet
	 *     FunctionalityModuleSet_Impl returns FunctionalityModuleSet
	 *
	 * Constraint:
	 *     (
	 *         name=EString 
	 *         usedTransformationOrScheme=[FunctionalityModule|QualifiedName]? 
	 *         scenario=[Scenario|QualifiedName]? 
	 *         scenarioSet=ScenarioSet? 
	 *         (subTransformationsAndSchemes+=FunctionalityModule subTransformationsAndSchemes+=FunctionalityModule*)?
	 *     )
	 */
	protected void sequence_FunctionalityModuleSet_Impl(ISerializationContext context, FunctionalityModuleSet semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Given returns Given
	 *
	 * Constraint:
	 *     (
	 *         text=[ClauseText|QualifiedName]? 
	 *         (regulatoryTextLinks+=[TitledRequirementsSection|QualifiedName] regulatoryTextLinks+=[TitledRequirementsSection|QualifiedName]*)? 
	 *         (params+=Param params+=Param*)?
	 *     )
	 */
	protected void sequence_Given(ISerializationContext context, Given semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     FunctionalityModule returns LeafFunctionalityModule
	 *     LeafFunctionalityModule_Impl returns LeafFunctionalityModule
	 *
	 * Constraint:
	 *     (name=EString usedTransformationOrScheme=[FunctionalityModule|QualifiedName]? scenario=[Scenario|QualifiedName]? scenarioSet=ScenarioSet?)
	 */
	protected void sequence_LeafFunctionalityModule_Impl(ISerializationContext context, LeafFunctionalityModule semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     MAINTENANCE_AGENCY returns MAINTENANCE_AGENCY
	 *
	 * Constraint:
	 *     (name=EString code=EString? maintenance_agency_id=EString?)
	 */
	protected void sequence_MAINTENANCE_AGENCY(ISerializationContext context, MAINTENANCE_AGENCY semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     MAPPING_DEFINITION returns MAPPING_DEFINITION
	 *
	 * Constraint:
	 *     (
	 *         mapping_id=EString 
	 *         name=EString? 
	 *         code=EString? 
	 *         maintenance_agency_id=EString? 
	 *         mapping_type=EString? 
	 *         memberMapping=[MEMBER_MAPPING|QualifiedName]? 
	 *         variableMapping=[VARIABLE_MAPPING|QualifiedName]?
	 *     )
	 */
	protected void sequence_MAPPING_DEFINITION(ISerializationContext context, MAPPING_DEFINITION semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     MEMBER_MAPPING_ITEM returns MEMBER_MAPPING_ITEM
	 *
	 * Constraint:
	 *     (isSource=EString? member=[MEMBER|QualifiedName]? variable=[VARIABLE|QualifiedName]?)
	 */
	protected void sequence_MEMBER_MAPPING_ITEM(ISerializationContext context, MEMBER_MAPPING_ITEM semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     MEMBER_MAPPING returns MEMBER_MAPPING
	 *
	 * Constraint:
	 *     (
	 *         member_mapping_id=EString 
	 *         name=EString? 
	 *         code=EString? 
	 *         maintenance_agency_id=EString? 
	 *         (memberMappingItems+=MEMBER_MAPPING_ITEM memberMappingItems+=MEMBER_MAPPING_ITEM*)?
	 *     )
	 */
	protected void sequence_MEMBER_MAPPING(ISerializationContext context, MEMBER_MAPPING semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     MEMBER returns MEMBER
	 *
	 * Constraint:
	 *     (
	 *         name=EString 
	 *         code=EString? 
	 *         description=EString? 
	 *         member_id=EString? 
	 *         domain_id=[DOMAIN|QualifiedName]? 
	 *         maintenance_agency_id=[MAINTENANCE_AGENCY|QualifiedName]?
	 *     )
	 */
	protected void sequence_MEMBER(ISerializationContext context, MEMBER semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     MappingDefinitionModule returns MappingDefinitionModule
	 *
	 * Constraint:
	 *     (
	 *         name=EString 
	 *         theDescription=EString? 
	 *         license=EString? 
	 *         version=EString? 
	 *         dependencies=ModuleDependencies? 
	 *         longName=ModuleLongName? 
	 *         (mappings+=MAPPING_DEFINITION mappings+=MAPPING_DEFINITION*)?
	 *     )
	 */
	protected void sequence_MappingDefinitionModule(ISerializationContext context, MappingDefinitionModule semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     MemberModule returns MemberModule
	 *
	 * Constraint:
	 *     (
	 *         name=EString 
	 *         theDescription=EString? 
	 *         license=EString? 
	 *         version=EString? 
	 *         dependencies=ModuleDependencies? 
	 *         longName=ModuleLongName? 
	 *         (members+=MEMBER members+=MEMBER*)?
	 *     )
	 */
	protected void sequence_MemberModule(ISerializationContext context, MemberModule semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ModuleDependencies returns ModuleDependencies
	 *
	 * Constraint:
	 *     (theModules+=ModuleDependency theModules+=ModuleDependency*)?
	 */
	protected void sequence_ModuleDependencies(ISerializationContext context, ModuleDependencies semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ModuleDependency returns ModuleDependency
	 *
	 * Constraint:
	 *     (moduleName=EString? moduleVersion=EString? theModule=[Module|QualifiedName]? longName=[ModuleLongName|QualifiedName]?)
	 */
	protected void sequence_ModuleDependency(ISerializationContext context, ModuleDependency semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ModuleLongName returns ModuleLongName
	 *
	 * Constraint:
	 *     name=EString
	 */
	protected void sequence_ModuleLongName(ISerializationContext context, ModuleLongName semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, Module_managementPackage.Literals.MODULE_LONG_NAME__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, Module_managementPackage.Literals.MODULE_LONG_NAME__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getModuleLongNameAccess().getNameEStringParserRuleCall_2_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     FunctionalityModule returns ParallelFunctionalityModule
	 *     ParallelFunctionalityModule returns ParallelFunctionalityModule
	 *
	 * Constraint:
	 *     (
	 *         name=EString 
	 *         usedTransformationOrScheme=[FunctionalityModule|QualifiedName]? 
	 *         scenario=[Scenario|QualifiedName]? 
	 *         scenarioSet=ScenarioSet? 
	 *         (subTransformationsAndSchemes+=FunctionalityModule subTransformationsAndSchemes+=FunctionalityModule*)?
	 *     )
	 */
	protected void sequence_ParallelFunctionalityModule(ISerializationContext context, ParallelFunctionalityModule semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Param returns Param
	 *
	 * Constraint:
	 *     param=[EObject|QualifiedName]?
	 */
	protected void sequence_Param(ISerializationContext context, Param semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     FunctionalityModule returns ReadDataSourceFunctionalityModule
	 *     ReadDataSourceFunctionalityModule returns ReadDataSourceFunctionalityModule
	 *
	 * Constraint:
	 *     (name=EString usedTransformationOrScheme=[FunctionalityModule|QualifiedName]? scenario=[Scenario|QualifiedName]? scenarioSet=ScenarioSet?)
	 */
	protected void sequence_ReadDataSourceFunctionalityModule(ISerializationContext context, ReadDataSourceFunctionalityModule semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     RequirementType returns RequirementType
	 *
	 * Constraint:
	 *     name=EString
	 */
	protected void sequence_RequirementType(ISerializationContext context, RequirementType semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, Requirements_textPackage.Literals.REQUIREMENT_TYPE__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, Requirements_textPackage.Literals.REQUIREMENT_TYPE__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getRequirementTypeAccess().getNameEStringParserRuleCall_2_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     RequirementsModule returns RequirementsModule
	 *
	 * Constraint:
	 *     (
	 *         name=EString 
	 *         theDescription=EString? 
	 *         license=EString? 
	 *         version=EString? 
	 *         dependencies=ModuleDependencies? 
	 *         longName=ModuleLongName? 
	 *         (rules+=TitledRequirementsSection rules+=TitledRequirementsSection*)? 
	 *         allowedtypes=AllowedTypes?
	 *     )
	 */
	protected void sequence_RequirementsModule(ISerializationContext context, RequirementsModule semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     RequirementsSection returns RequirementsSectionImage
	 *     RequirementsSectionImage returns RequirementsSectionImage
	 *
	 * Constraint:
	 *     (name=EString style=EString? uri=EString?)
	 */
	protected void sequence_RequirementsSectionImage(ISerializationContext context, RequirementsSectionImage semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     RequirementsSection returns RequirementsSectionLinkWithText
	 *     RequirementsSectionLinkWithText returns RequirementsSectionLinkWithText
	 *
	 * Constraint:
	 *     (name=EString linkText=EString? subsection=EString? linkedRuleSection=[TitledRequirementsSection|QualifiedName]?)
	 */
	protected void sequence_RequirementsSectionLinkWithText(ISerializationContext context, RequirementsSectionLinkWithText semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     RequirementsSection returns RequirementsSectionText
	 *     RequirementsSectionText returns RequirementsSectionText
	 *
	 * Constraint:
	 *     (name=EString text=EString?)
	 */
	protected void sequence_RequirementsSectionText(ISerializationContext context, RequirementsSectionText semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Result returns Result
	 *
	 * Constraint:
	 *     {Result}
	 */
	protected void sequence_Result(ISerializationContext context, Result semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     SUBDOMAIN returns SUBDOMAIN
	 *
	 * Constraint:
	 *     (
	 *         is_listed?='is_listed'? 
	 *         is_natural?='is_natural'? 
	 *         subdomain_id=EString 
	 *         code=EString? 
	 *         description=EString? 
	 *         name=EString? 
	 *         domain_id=[DOMAIN|QualifiedName]? 
	 *         facet_id=[FACET_COLLECTION|QualifiedName]? 
	 *         maintenance_agency_id=[MAINTENANCE_AGENCY|QualifiedName]?
	 *     )
	 */
	protected void sequence_SUBDOMAIN(ISerializationContext context, SUBDOMAIN semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     FunctionalityModule returns ScenarioSetFunctionalityModule
	 *     ScenarioSetFunctionalityModule returns ScenarioSetFunctionalityModule
	 *
	 * Constraint:
	 *     (
	 *         name=EString 
	 *         usedTransformationOrScheme=[FunctionalityModule|QualifiedName]? 
	 *         scenario=[Scenario|QualifiedName]? 
	 *         scenarioSet=ScenarioSet? 
	 *         (subTransformationsAndSchemes+=FunctionalityModule subTransformationsAndSchemes+=FunctionalityModule*)? 
	 *         scenarioSetChoice=ScenarioSet?
	 *     )
	 */
	protected void sequence_ScenarioSetFunctionalityModule(ISerializationContext context, ScenarioSetFunctionalityModule semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ScenarioSet returns ScenarioSet
	 *
	 * Constraint:
	 *     (name=EString (scenarios+=Scenario scenarios+=Scenario*)?)
	 */
	protected void sequence_ScenarioSet(ISerializationContext context, ScenarioSet semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Scenario returns Scenario
	 *
	 * Constraint:
	 *     name=EString
	 */
	protected void sequence_Scenario(ISerializationContext context, Scenario semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ScenariosPackage.Literals.SCENARIO__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ScenariosPackage.Literals.SCENARIO__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getScenarioAccess().getNameEStringParserRuleCall_2_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     FunctionalityModule returns SerialFunctionalityModule
	 *     SerialFunctionalityModule returns SerialFunctionalityModule
	 *
	 * Constraint:
	 *     (
	 *         name=EString 
	 *         usedTransformationOrScheme=[FunctionalityModule|QualifiedName]? 
	 *         scenario=[Scenario|QualifiedName]? 
	 *         scenarioSet=ScenarioSet? 
	 *         (subTransformationsAndSchemes+=FunctionalityModule subTransformationsAndSchemes+=FunctionalityModule*)?
	 *     )
	 */
	protected void sequence_SerialFunctionalityModule(ISerializationContext context, SerialFunctionalityModule semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     SmcubesModel returns SmcubesModel
	 *
	 * Constraint:
	 *     (
	 *         name=EString 
	 *         (domains+=DomainModule domains+=DomainModule*)? 
	 *         (members+=MemberModule members+=MemberModule*)? 
	 *         (variables+=VariableModule variables+=VariableModule*)? 
	 *         (cubes+=CubeModule cubes+=CubeModule*)? 
	 *         (combinations+=CombinationModule combinations+=CombinationModule*)? 
	 *         (functionalModules+=TransformationSchemeModule functionalModules+=TransformationSchemeModule*)? 
	 *         (mappings+=MappingDefinitionModule mappings+=MappingDefinitionModule*)?
	 *     )
	 */
	protected void sequence_SmcubesModel(ISerializationContext context, SmcubesModel semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     TRANSFORMATION_SCHEME returns TRANSFORMATION_SCHEME
	 *
	 * Constraint:
	 *     (
	 *         transformation_scheme_id=EString 
	 *         description=EString? 
	 *         name=EString? 
	 *         code=EString? 
	 *         maintenance_agency_id=EString? 
	 *         version=EString? 
	 *         valid_to=EDate? 
	 *         valid_from=EDate?
	 *     )
	 */
	protected void sequence_TRANSFORMATION_SCHEME(ISerializationContext context, TRANSFORMATION_SCHEME semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     TestContraints returns TestContraints
	 *
	 * Constraint:
	 *     (
	 *         name=EString 
	 *         template=[TestTemplate|QualifiedName]? 
	 *         (givenParams+=Param givenParams+=Param*)? 
	 *         (whenParams+=Param whenParams+=Param*)? 
	 *         (thenParams+=Param thenParams+=Param*)?
	 *     )
	 */
	protected void sequence_TestContraints(ISerializationContext context, TestContraints semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     TestDefinitionModule returns TestDefinitionModule
	 *
	 * Constraint:
	 *     (
	 *         name=EString 
	 *         theDescription=EString? 
	 *         license=EString? 
	 *         version=EString? 
	 *         dependencies=ModuleDependencies? 
	 *         longName=ModuleLongName? 
	 *         (testDefinitions+=TestDefinition testDefinitions+=TestDefinition*)?
	 *     )
	 */
	protected void sequence_TestDefinitionModule(ISerializationContext context, TestDefinitionModule semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     TestDefinition returns TestDefinition
	 *     TestDefinition_Impl returns TestDefinition
	 *
	 * Constraint:
	 *     (name=EString testContraints=[TestContraints|QualifiedName]? given=Given? when=When? then=Then?)
	 */
	protected void sequence_TestDefinition_Impl(ISerializationContext context, TestDefinition semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     TestInputData returns TestInputData
	 *
	 * Constraint:
	 *     name=EString
	 */
	protected void sequence_TestInputData(ISerializationContext context, TestInputData semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, Test_input_dataPackage.Literals.TEST_INPUT_DATA__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, Test_input_dataPackage.Literals.TEST_INPUT_DATA__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getTestInputDataAccess().getNameEStringParserRuleCall_2_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     TestModule returns TestModule
	 *
	 * Constraint:
	 *     (
	 *         name=EString 
	 *         theDescription=EString? 
	 *         license=EString? 
	 *         version=EString? 
	 *         dependencies=ModuleDependencies? 
	 *         longName=ModuleLongName? 
	 *         (tests+=E2ETest tests+=E2ETest*)?
	 *     )
	 */
	protected void sequence_TestModule(ISerializationContext context, TestModule semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     TestTemplateModule returns TestTemplateModule
	 *
	 * Constraint:
	 *     (
	 *         name=EString 
	 *         theDescription=EString? 
	 *         license=EString? 
	 *         version=EString? 
	 *         dependencies=ModuleDependencies? 
	 *         longName=ModuleLongName? 
	 *         (templates+=TestTemplate templates+=TestTemplate*)?
	 *     )
	 */
	protected void sequence_TestTemplateModule(ISerializationContext context, TestTemplateModule semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     TestTemplate returns TestTemplate
	 *
	 * Constraint:
	 *     (
	 *         name=EString 
	 *         givenText=ClauseText? 
	 *         whenText=ClauseText? 
	 *         thenText=ClauseText? 
	 *         (givenParams+=Param givenParams+=Param*)? 
	 *         (whenParams+=Param whenParams+=Param*)? 
	 *         (thenParams+=Param thenParams+=Param*)?
	 *     )
	 */
	protected void sequence_TestTemplate(ISerializationContext context, TestTemplate semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Then returns Then
	 *
	 * Constraint:
	 *     (
	 *         text=[ClauseText|QualifiedName]? 
	 *         (regulatoryTextLinks+=[TitledRequirementsSection|QualifiedName] regulatoryTextLinks+=[TitledRequirementsSection|QualifiedName]*)? 
	 *         (params+=Param params+=Param*)?
	 *     )
	 */
	protected void sequence_Then(ISerializationContext context, Then semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     RequirementsSection returns TitledRequirementsSection
	 *     TitledRequirementsSection returns TitledRequirementsSection
	 *
	 * Constraint:
	 *     (
	 *         name=EString 
	 *         title=EString? 
	 *         referencingSections=[RequirementsSectionLinkWithText|QualifiedName]? 
	 *         requirementsType=[RequirementType|QualifiedName] 
	 *         (sections+=RequirementsSection sections+=RequirementsSection*)?
	 *     )
	 */
	protected void sequence_TitledRequirementsSection(ISerializationContext context, TitledRequirementsSection semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     TransformationSchemeModule returns TransformationSchemeModule
	 *
	 * Constraint:
	 *     (
	 *         name=EString 
	 *         theDescription=EString? 
	 *         license=EString? 
	 *         version=EString? 
	 *         dependencies=ModuleDependencies? 
	 *         longName=ModuleLongName? 
	 *         (schemes+=TRANSFORMATION_SCHEME schemes+=TRANSFORMATION_SCHEME*)?
	 *     )
	 */
	protected void sequence_TransformationSchemeModule(ISerializationContext context, TransformationSchemeModule semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     TestDefinition returns UnitTestDefinition
	 *     UnitTestDefinition returns UnitTestDefinition
	 *
	 * Constraint:
	 *     (name=EString testContraints=[TestContraints|QualifiedName]? given=Given? when=When? then=Then?)
	 */
	protected void sequence_UnitTestDefinition(ISerializationContext context, UnitTestDefinition semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     VARIABLE_MAPPING_ITEM returns VARIABLE_MAPPING_ITEM
	 *
	 * Constraint:
	 *     (isSource=EString? variable=[VARIABLE|QualifiedName]?)
	 */
	protected void sequence_VARIABLE_MAPPING_ITEM(ISerializationContext context, VARIABLE_MAPPING_ITEM semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     VARIABLE_MAPPING returns VARIABLE_MAPPING
	 *
	 * Constraint:
	 *     (
	 *         variable_mapping_id=EString 
	 *         name=EString? 
	 *         code=EString? 
	 *         maintenance_agency_id=EString? 
	 *         (varaibleMappingItems+=VARIABLE_MAPPING_ITEM varaibleMappingItems+=VARIABLE_MAPPING_ITEM*)?
	 *     )
	 */
	protected void sequence_VARIABLE_MAPPING(ISerializationContext context, VARIABLE_MAPPING semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     VARIABLE_SET returns VARIABLE_SET
	 *
	 * Constraint:
	 *     (variable_set_id=EString code=EString? description=EString? name=EString? maintenance_agency_id=[MAINTENANCE_AGENCY|QualifiedName]?)
	 */
	protected void sequence_VARIABLE_SET(ISerializationContext context, VARIABLE_SET semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     VARIABLE returns VARIABLE
	 *
	 * Constraint:
	 *     (
	 *         name=EString 
	 *         code=EString? 
	 *         description=EString? 
	 *         primary_concept=EString? 
	 *         variable_id=EString? 
	 *         domain_id=[DOMAIN|QualifiedName]? 
	 *         maintenance_agency_id=[MAINTENANCE_AGENCY|QualifiedName]?
	 *     )
	 */
	protected void sequence_VARIABLE(ISerializationContext context, VARIABLE semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     FunctionalityModule returns ValidationFunctionalityModule
	 *     ValidationFunctionalityModule returns ValidationFunctionalityModule
	 *
	 * Constraint:
	 *     (name=EString usedTransformationOrScheme=[FunctionalityModule|QualifiedName]? scenario=[Scenario|QualifiedName]? scenarioSet=ScenarioSet?)
	 */
	protected void sequence_ValidationFunctionalityModule(ISerializationContext context, ValidationFunctionalityModule semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     VariableModule returns VariableModule
	 *
	 * Constraint:
	 *     (
	 *         name=EString 
	 *         theDescription=EString? 
	 *         license=EString? 
	 *         version=EString? 
	 *         dependencies=ModuleDependencies? 
	 *         longName=ModuleLongName? 
	 *         (variables+=VARIABLE variables+=VARIABLE*)?
	 *     )
	 */
	protected void sequence_VariableModule(ISerializationContext context, VariableModule semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     When returns When
	 *
	 * Constraint:
	 *     (
	 *         text=[ClauseText|QualifiedName]? 
	 *         (regulatoryTextLinks+=[TitledRequirementsSection|QualifiedName] regulatoryTextLinks+=[TitledRequirementsSection|QualifiedName]*)? 
	 *         (params+=Param params+=Param*)?
	 *     )
	 */
	protected void sequence_When(ISerializationContext context, When semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     rogram returns Program
	 *
	 * Constraint:
	 *     (
	 *         smCubesModel=SmcubesModel? 
	 *         requirements=RequirementsModule? 
	 *         testDefinitions=TestDefinitionModule? 
	 *         tests=TestModule? 
	 *         testTemplates=TestTemplateModule? 
	 *         testConstriants=TestContraints? 
	 *         functionalityModules=FunctionalityModuleModule?
	 *     )
	 */
	protected void sequence_rogram(ISerializationContext context, Program semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
}

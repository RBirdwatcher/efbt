<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<xsd:schema xmlns:column_transformation_logic="http://www.eclipse.org/column_transformation_logic" xmlns:core="http://www.eclipse.org/core" xmlns:cube_transformation_logic="http://www.eclipse.org/cube_transformation_logic" xmlns:cubes="http://www.eclipse.org/cubes" xmlns:ecore="http://www.eclipse.org/emf/2002/Ecore" xmlns:functions="http://www.eclipse.org/functions" xmlns:xsd="http://www.w3.org/2001/XMLSchema" ecore:nsPrefix="cube_transformation_logic" ecore:package="cube_transformation_logic" targetNamespace="http://www.eclipse.org/cube_transformation_logic">
  <xsd:import namespace="http://www.eclipse.org/column_transformation_logic" schemaLocation="column_transformation_logic.xsd"/>
  <xsd:import namespace="http://www.eclipse.org/emf/2002/Ecore" schemaLocation="../../org.eclipse.emf.ecore/model/Ecore.xsd"/>
  <xsd:import namespace="http://www.eclipse.org/cubes" schemaLocation="cubes.xsd"/>
  <xsd:import namespace="http://www.eclipse.org/functions" schemaLocation="functions.xsd"/>
  <xsd:import namespace="http://www.eclipse.org/core" schemaLocation="core.xsd"/>
  <xsd:annotation>
    <xsd:documentation> This package describes the logic for cube transformations  

</xsd:documentation>
  </xsd:annotation>
  <xsd:annotation>
    <xsd:appinfo ecore:key="license" source="license">Copyright (c) 2020 Bird Software Solutions Ltd
 All rights reserved. This file and the accompanying materials are made available under the terms of the Eclipse Public License v2.0 which accompanies this distribution, and is available at http://www.eclipse.org/legal/epl-v20.html

SPDX-License-Identifier: EPL-2.0 

 Contributors:
 Neil Mackenzie - initial API and implementation&#13;</xsd:appinfo>
  </xsd:annotation>
  <xsd:complexType name="CustomRowFunction">
    <xsd:annotation>
      <xsd:documentation> A CustomRowFunction is responsible for creating rows and linking them to rows in the source cubes when we wish 	to do this in a way that doesn't follow common patterns such as filtering or grouping. 
Examples could be matching     	financial collateral and exposures in the most efficient way, which typically requires iterative or recursive logic.
The end result in this case would still be created rows which link back to the required collateral row and exposure row, even though the logic of finding the correct pairing of collateral and exposure may be quite complex.
            	 </xsd:documentation>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="cube_transformation_logic:RowFunction">
        <xsd:attribute ecore:reference="core:VARIABLE" name="dependantVariables">
          <xsd:annotation>
            <xsd:documentation>The Columns from the source cubes which are used to determine how to create and link the created rows. 
            	 </xsd:documentation>
          </xsd:annotation>
          <xsd:simpleType>
            <xsd:list itemType="xsd:anyURI"/>
          </xsd:simpleType>
        </xsd:attribute>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="FilterAndGroupToOneRowFunction">
    <xsd:annotation>
      <xsd:documentation>A Function description which describes how single rows are created by grouping  multiple rows from a source cube according to a grouping condition, while also filtering the source rows by a filter condition</xsd:documentation>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="cube_transformation_logic:RowFunction">
        <xsd:sequence>
          <xsd:element ecore:resolveProxies="true" minOccurs="0" name="filterFunction" type="functions:BooleanFunction">
            <xsd:annotation>
              <xsd:documentation>The function that defines the filter condition</xsd:documentation>
            </xsd:annotation>
          </xsd:element>
        </xsd:sequence>
        <xsd:attribute ecore:reference="core:VARIABLE" name="groupByVariables">
          <xsd:annotation>
            <xsd:documentation>The columns to use to group the source cube by, e.g. grouping a cube by a a column called Currency will lead to one row per unique currency in the source cube rows.</xsd:documentation>
          </xsd:annotation>
          <xsd:simpleType>
            <xsd:list itemType="xsd:anyURI"/>
          </xsd:simpleType>
        </xsd:attribute>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="FunctionalCubeLogic">
    <xsd:annotation>
      <xsd:documentation>A description of logic and dependencies for describing how the set rows in a derived cube is created, and how the source rows of each of those rows is set.
      For example a FunctionalCubeeLogic describing a Group By situation on 1 million trades by currency, would result in the derived cube
      having one row per currency, and each of those rows would have a link to all the source rows with that currency.</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:element ecore:resolveProxies="true" minOccurs="0" name="rowFunction" type="cube_transformation_logic:RowFunction">
        <xsd:annotation>
          <xsd:documentation>The RowFunction which describes how Rows are generated, this will be a sub class of RowFunction such as JoinRowFunction</xsd:documentation>
        </xsd:annotation>
      </xsd:element>
    </xsd:sequence>
    <xsd:attribute ecore:reference="cubes:FreeBirdToolsCube" name="cube" type="xsd:anyURI">
      <xsd:annotation>
        <xsd:documentation>The derivedCube</xsd:documentation>
      </xsd:annotation>
    </xsd:attribute>
    <xsd:attribute ecore:id="true" name="name" type="ecore:EString">
      <xsd:annotation>
        <xsd:documentation>The name of the FunctionalCubeLogic</xsd:documentation>
      </xsd:annotation>
    </xsd:attribute>
    <xsd:attribute ecore:reference="cubes:FreeBirdToolsCube" name="ultimateCubeSource" type="xsd:anyURI">
      <xsd:annotation>
        <xsd:documentation>depricated</xsd:documentation>
      </xsd:annotation>
    </xsd:attribute>
  </xsd:complexType>
  <xsd:complexType name="OneToOneRowFunction">
    <xsd:annotation>
      <xsd:documentation>A Function description which describes how a single rows is created for each single row in a source cube</xsd:documentation>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="cube_transformation_logic:RowFunction"/>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="RowFilterFunction">
    <xsd:annotation>
      <xsd:documentation>A Function description which describes how single rows are created by filtering  single rows from a source cube according to a filter condition</xsd:documentation>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="cube_transformation_logic:RowFunction">
        <xsd:sequence>
          <xsd:element ecore:resolveProxies="true" minOccurs="0" name="filterFunction" type="functions:BooleanFunction">
            <xsd:annotation>
              <xsd:documentation>The function that defines the filter condition</xsd:documentation>
            </xsd:annotation>
          </xsd:element>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="RowFunction">
    <xsd:annotation>
      <xsd:documentation>The RowFunction which describes how Rows are generated, and linked to rows from the source cubes.
            	 The row Function by default does not set any column values in the rows, however to allow complete flexibility in the language, we also allow optionally for the row function to set fields in the created row. </xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:element ecore:resolveProxies="true" maxOccurs="unbounded" minOccurs="0" name="dependantCubeColumns" type="functions:ResolvedCubeColumnParameter">
        <xsd:annotation>
          <xsd:documentation>The parameters (from functions) which contain the CubeColumns from the source which are used to determine how to create and link the created rows. 
            	For example these could  be the CubeColumns used for grouping, or filtering, or joining. </xsd:documentation>
        </xsd:annotation>
      </xsd:element>
      <xsd:element ecore:resolveProxies="true" maxOccurs="unbounded" minOccurs="0" name="createdCubeColumns" type="column_transformation_logic:CubeColumn">
        <xsd:annotation>
          <xsd:documentation>Any cubeColumns which are set explicitly by the row function. 
An example here would be uniquely setting a CubeColumn called index if the row function is responsable for creating multiple rows from one source row.
Another example would be setting a field called index if the row is responsable for ordering a set of rows and setting index to indicate ordering position.
In most common cases this field is empty.</xsd:documentation>
        </xsd:annotation>
      </xsd:element>
    </xsd:sequence>
  </xsd:complexType>
  <xsd:complexType name="RowGroupByFunction">
    <xsd:annotation>
      <xsd:documentation>A Function description which describes how single rows are created by grouping  multiple rows from a source cube according to a grouping condition</xsd:documentation>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="cube_transformation_logic:RowFunction">
        <xsd:attribute ecore:reference="core:VARIABLE" name="groupByColumns">
          <xsd:annotation>
            <xsd:documentation>The columns to use to group the source cube by, e.g. grouping a  cube by a a column called Currency will lead to one row per unique currency in the source cube rows.</xsd:documentation>
          </xsd:annotation>
          <xsd:simpleType>
            <xsd:list itemType="xsd:anyURI"/>
          </xsd:simpleType>
        </xsd:attribute>
        <xsd:attribute ecore:reference="column_transformation_logic:CubeColumn" name="groupByCubeColumns">
          <xsd:annotation>
            <xsd:documentation>The CubeColumns to use to group the source cube by, e.g. grouping a cube by a a column called Currency will lead to one row per unique currency in the source cube rows.</xsd:documentation>
          </xsd:annotation>
          <xsd:simpleType>
            <xsd:list itemType="xsd:anyURI"/>
          </xsd:simpleType>
        </xsd:attribute>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="RowJoinFunction">
    <xsd:annotation>
      <xsd:documentation>A Function description which describes how single rows are created by joining single rows from 2 source cubes according to a join condition</xsd:documentation>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="cube_transformation_logic:RowFunction">
        <xsd:sequence>
          <xsd:element ecore:resolveProxies="true" minOccurs="0" name="joinFunction" type="functions:BooleanFunction">
            <xsd:annotation>
              <xsd:documentation>The function that defines the join condition</xsd:documentation>
            </xsd:annotation>
          </xsd:element>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="UnionRowFunction">
    <xsd:annotation>
      <xsd:documentation> A Row function  which creates the union of multiple source cubes, all of which must have the exact same structure.
            	 </xsd:documentation>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="cube_transformation_logic:RowFunction"/>
    </xsd:complexContent>
  </xsd:complexType>
</xsd:schema>
